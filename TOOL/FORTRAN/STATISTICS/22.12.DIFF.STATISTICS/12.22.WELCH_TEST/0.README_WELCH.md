# Welch's t-test

[[_TOC_]]

## 理論

0.README_WELCH_TEST_THEORY.pdf

https://rosettacode.org/wiki/Welch%27s_t-test



## SAMPLE FORTRAN PROGRAM

**WELCH_TEST.F90**

```fortran
subroutine welch_ttest(n1, x1, n2, x2, t, df, p)
implicit none
integer :: n1, n2
double precision :: x1(n1), x2(n2)
double precision :: m1, m2, v1, v2, t, df, p
double precision :: dbetai
    
m1 = sum(x1) / n1
m2 = sum(x2) / n2
v1 = sum((x1 - m1)**2) / (n1 - 1)
v2 = sum((x2 - m2)**2) / (n2 - 1)
t = (m1 - m2) / sqrt(v1 / n1 + v2 / n2)

df = (v1 / n1 + v2 / n2)**2 / &
     (v1**2 / (n1**2 * (n1 - 1)) + v2**2 / (n2**2 * (n2 - 1)))

PRINT '(2f10.3)',m1,m2
PRINT '(2f10.3)',v1,v2
PRINT '(f10.5,f10.2)',t,df

p = dbetai(df / (t**2 + df), 0.5d0 * df, 0.5d0)

end subroutine

program pvalue
implicit none
double precision :: x(10) = [13.8, 10.2, 4.6, 10.0, 4.2, 16.1, 14.4, 4.9, 7.7, 11.4]
double precision :: y(11) = [3.3, 2.6, 4.0, 4.7, 1.9, 2.9, 4.7, 5.3, 4.3, 3.0, 2.0]
!double precision :: x(4) = [3d0, 4d0, 1d0, 2.1d0]
!double precision :: y(3) = [490.2d0, 340.0d0, 433.9d0]

double precision :: t, df, p

call welch_ttest(10, x, 11, y, t, df, p)
!call welch_ttest(4, x, 3, y, t, df, p)

PRINT *
PRINT '(A,F10.2)','t =', t
PRINT '(A,F10.2)','df=', df
PRINT '(A,F10.7)','p= ', p
end program
```

dbetaiが使用している副プログラムリスト: [SUB_WELCH.F]()

コンパイル・実行用スクリプト: [WELCH_TEST.sh]()



## FORTRANプログラムの結果の検証

### プログラム実行結果

```bash
$ WELCH_TEST.sh 
     9.730     3.518
    18.487     1.328
   4.42644     10.17
 DGAMMA.F 85: D1MACH(3)=  1.110223024625157E-016
 
t =      4.43
df=     10.17
p=  0.0012286
```



## Rによる検算

R にてt検定を実行する．t検定は対応のないt検定と対応のあるt検定に分けられ，さらに，対応のないt検定は[スチューデントのt検定](https://data-science.gr.jp/theory/tst_student_t_test.html)と[ウェルチのt検定](https://data-science.gr.jp/theory/tst_welch_t_test.html)のふたつに分類される．スチューデントのt検定やウェルチのt検定は，2群間の平均値が独立である場合に用いることができる．例えば，東京都と大阪府出身の成人男性の身長の平均値の差の検定とかをしたい場合には対応がないt検定を使う．スチューデントおよびウェルチの2種類の検定法は，与えられた2群のデータが互いに等分散であるかどうかに基づいて，その使用を決定する．2群間の分散が等しい場合にはスチューデントのt検定を，等分散とはみなせられない場合には**ウェルチの検定**を用いる．等分散性の検定には[F検定](https://data-science.gr.jp/theory/tst_f_test.html)を用いることができる．F検定の後にt検定を用いることは検定の繰り返し行為に該当するため，やってはいけない。**等分散かどうかわからない場合最初からウェルチの検定を使う**。

### t検定の使い分け

t検定は以下の表に従って使い分ける．

| 状況                                                | 適用すべきt検定                                              |
| :-------------------------------------------------- | :----------------------------------------------------------- |
| データに対応がある．                                | [対応のあるt検定](https://data-science.gr.jp/implementation/ist_r_welch_t_test.html) |
| データに対応がなく，2群間に等分散性が仮定できる．   | [スチューデントのt検定](https://data-science.gr.jp/implementation/ist_r_student_t_test.html) |
| データに対応がなく，2群間に等分散性が仮定できない． | ウェルチのt検定                                              |

### p値の計算

ウェルチのt検定を行うために以下のようなデータを考える．データXの値は平均値9，標準偏差3.5の正規分布に従う値で，データYの値は平均値3，標準偏差1.5の正規分布に従う値である．

| データX | 13.8, 10.2, 4.6, 10.0, 4.2, 16.1, 14.4, 4.9, 7.7, 11.4 |
| ------- | ------------------------------------------------------ |
| データY | 3.3, 2.6, 4.0, 4.7, 1.9, 2.9, 4.7, 5.3, 4.3, 3.0, 2.0  |

これらのデータを以下のようなコマンドで，適当な変数，vx と vy に読み込む．

```R
$ vx=c(13.8, 10.2, 4.6, 10.0, 4.2, 16.1, 14.4, 4.9, 7.7, 11.4)
$ vy=c(3.3, 2.6, 4.0, 4.7, 1.9, 2.9, 4.7, 5.3, 4.3, 3.0, 2.0)
```

これらのデータのサンプルサイズは一致しないので，少なくとも対応はない．よって，スチューデントかウェルチのt検定を行う．

ここではウェルチのt検定を用いる．ウェルチのt検定はコマンド t.test() にて実行できる．実際には，t.test(x=データセット1,y=データセット2,var.equal=F,paired=F) とする．有意水準は0.05とする．**帰無仮説 (H0) は，2群間の平均値に差がないこと**，となる．

```R
$ t.test(x=vx,y=vy,var.equal=F,paired=F)
```

これを実行した結果は以下のようになる．1行目の Welch Two Sample t-test とう表記がウェルチのt検定を実行したことを示している．結果から，p<0.05 なので帰無仮説が棄却され，これらの2群間には差があると結論する．

```R
        Welch Two Sample t-test

data:  vx and vy
t = 4.4264, df = 10.174, p-value = 0.001229
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 3.092228 9.331408
sample estimates:
mean of x mean of y 
 9.730000  3.518182 
```



## NCL SAMPLE FOR T-TEST

**JUST FOR REFERENCE**

/work09/am/00.WORK/2023.HEAT_FLUX_TREND/32.JOFURO3_DECOMP_FLUX/32.12.TREND_SEA_FIG

```fortran
print("MMMMM JUDGE SIGNIFICANCE")
;https://ccsr.aori.u-tokyo.ac.jp/~masakazu/memo/ncl/trend_signif.ncl
siglvl = 0.1 ;0.05
sighalf=siglvl/2.0
sigpct=siglvl*100
copyatt(trend,ts)  ; copy other atts and cv's
tval = onedtond(trend@tval , dimsizes(trend))
df   = onedtond(trend@nptxy, dimsizes(trend)) - 2
b    = tval
b    = 0.5        ; b must be same size as tval (and df)
prob = betainc(df/(df+tval^2),df/2.0,b)
```

```fortran
prob = betainc(df/(df+tval^2),df/2.0,b)
```



## NCL betainc

Evaluates the incomplete beta function.

### Prototype

```fortran
	function betainc (
		x  : numeric,  
		a  : numeric,  
		b  : numeric   
	)

	return_val [dimsizes(x)] :  typeof(x)
```



### Arguments

*x*

upper limit of integration. *x* may be of any dimensionality. *x* must be in (0,1) inclusive and can only be float or double.

*a*

first beta distribution parameter; must be > 0.0. It must be the same dimensionality as *x*.

*b*

second beta distribution parameter; must be > 0.0. It must be the same dimensionality as *x*.



### Return value

The variable returned will be the same type and dimensionality as *x*.

As of [NCL version 4.3.1](https://www.ncl.ucar.edu/prev_releases.shtml#4.3.1), if *x* contains [missing values](https://www.ncl.ucar.edu/Document/Language/fillval.shtml), the return value will contain missing values in the same locations.



### Description

**betainc** calculates the incomplete beta function. The incomplete beta function ratio is the probability that a random variable from a beta distribution having parameters *a* and *b* will be less than or equal to *x*. The code used is from SLATEC (http://www.netlib.org/slatec/fnlib/). This returns the same answers as the *Numerical Recipes* [Cambridge Univ. Press, 1986] function *betai*.

This function is often used to determine probabilities.

**Note:** in [NCL version 4.3.1](https://www.ncl.ucar.edu/prev_releases.shtml#4.3.1), this function was updated to handle missing values. If any missing values are inputted, the output array will contain missing values in the same locations.



### Examples

**Example 1**



```fortran
  a = 0.5
  b = 5.0
  x = 0.2

  alpha = betainc(x,a,b) 
  print("alpha(x,a,b)="+alpha)

  x = 0.5
  alpha = betainc(x,a,b) 
  print("alpha(x,a,b)="+alpha)
```

The result is:

```fortran
  alpha(x,a,b)= 0.85507
  alpha(x,a,b)= 0.98988
```

**Example 2** - The **betainc** can be used as a [p-Value calculator for the Student t-test](http://www.danielsoper.com/statcalc/calc08.aspx). Let's say a calculation has been made where the degrees-of-freedom (`df`=20) and a Student-t value of 2.08 has been determined. A probability level may be determined via:

```fortran
  df   = 20 
  tval = 2.08  
  prob = betainc( df/(df+tval^2), df/2.0, 0.5)
  print ("prob="+prob)
```

The result is `prob` = 0.0506. This is a two-tailed probability. The one-tailed probability is 0.5*`prob` = 0.0253,

For plotting, users often prefer to plot the quantity:

```fortran
   prob = (1.-betainc(x,a,b))*100.  ; probability in %
```