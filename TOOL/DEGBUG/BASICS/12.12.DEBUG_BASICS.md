# デバッグ 基礎編 

[[_TOC_]]

## デバッグとは

プログラム製作者の意図通りに動作するようにプログラムの誤りを直すこと  



## 予備知識

例としてプログラミング言語のFortranを用いている。下記学習済みだと理解が深まる（未習でも概略の把握は可能）。

https://gitlab.com/infoaofd/lab/-/tree/master/FORTRAN/PROGRAM_2022



## 参考資料

### Fortranデバッグの実習


https://itpass.scitec.kobe-u.ac.jp/~fourtran/Nagoya-Fortran/seminar-6.5/ppt/seminar-6.5.pdf

### Gradsでのデバッグ方法

https://gitlab.com/infoaofd/lab/-/blob/master/DEGBUG/BASICS/22.12.GRADS_DEBUG.md

### デバッグの実例

https://gitlab.com/infoaofd/lab/-/tree/master/DEGBUG/RECIPE



## プログラムの誤りの種類

### エラー (error)　

プログラムの誤り。実行できない

- コンパイル・エラー (翻訳時のエラー)

- ランタイム・エラー (実行時のエラー)


### 警告 (warning)

　あなたの意図通りには実行できないかもしれません（場合によっては無視できる）     



## エラーの種類と対策の基本

### コンパイルエラー

#### 文法エラー

プログラムに用いる言語(プログラミング言語)の文法を守っていない。

コンピューターは人間ほど融通が利かず，行間を読んだりすることができない。

そのため，人間が使う普段使う言語(日本語など)と比較して，プログラミング言語は文法に厳格である。これは，どのコンピューターがを使っても同じ結果が出ることを保証する上でも必要なことである。

##### FORTRANの文法エラーの例

```
$ ifort BI.F90 BILINEAR.F90 -o BI.exe
```

##### エラーメッセージ

```
BILINEAR.F90(1): **error** #5082: **Syntax error**, found IDENTIFIER 'BILINEAR' when expecting one of: ( : % [ . = =>  
UBROUTINE BILINEAR(XA,YA,ZA, X,Y, Z)  
----------^  
BILINEAR.F90(2): error #6236: A specification statement cannot appear in the executable section.  
REAL, INTENT(IN) :: XA(4), YA(4), ZA(4)  
```

**Syntax error** (シンタックスエラー)：文法エラー　**打ち間違いが原因のことが多い** 

##### エラーの個所  

```FORTRAN
UBROUTINE BILINEAR(XA,YA,ZA, X,Y, Z) 
----^  
```

**Sが抜けていて**UBROUTINEになっている。  



### ランタイムエラー

コンパイル時のエラーチェックには該当しなかったが，実行時にプログラムの矛盾が表面化する場合である。よくあるエラーとしては，次のようなものがある。

#### サブルーチン(関数)の引数のエラー

メインルーチンとサブルーチン(関数)で変数の, 

- 数

- 順序

- 種類（型）

が矛盾している 。 

コンパイル時ではなく**実行時にエラー**となる

##### FORTRANの文法エラーの例

```
$ BI.exe <INPUT.TXT   
```

forrtl: severe (174): **SIGSEGV**, **segmentation fault** occurred  

174は**エラーの番号**。**検索する**と調べられる。キーワードは **ifort** 番号    

**segmentation fault**: メモリの不正使用    

##### エラーの分析

$ cat BI.F90

```Fortran
PROGRAM BI
...
CALL BILINEAR(XA,YA,ZA, X,Y)
```

$ cat BILINEAR.F90 

```Fortran
SUBROUTINE BILINEAR(XA,YA,ZA, X,Y, Z)
```

BILINEAR.F90   

```Fortran
SUBROUTINE BILINEAR(XA,YA,ZA, X,Y, Z)
```

となっているが，BI.F90では，  

```fortran
CALL BILINEAR(XA,YA,ZA, X,Y)
```

となっており，**変数Zがない**。**変数の数が一致していない**ので，メモリの不正アクセスが起こる。  



### 配列の要素数オーバー

配列に値を代入するとき、サイズを超えて要素を入れようとするとエラーとなる。  

#### FORTRANのランライムエラーの例

```Fortran
REAL A(10)
```

と宣言したのにかかわらず，  存在しないA(11A)にアクセスしようとするとエラーになる。  

```Fortran
X=A(11)
```

この手のエラーは，  

```Fortran
I=11
....
X=A(I)
```

のように配列番号を変数で指定したときに起こりやすい。  



##### segmentation faultの説明

https://jp.xlsoft.com/documents/intel/compiler/18/for_18_win_lin/GUID-44448B78-2B87-4998-9828-C8BAEB9F5C9A.html  


severe (174): **SIGSEGV**, message-text (致命的なエラー (174): SIGSEGV、メッセージテキスト)  

このエラー番号には、次の 2 種類のメッセージのうち 1 つが発行されます。   

- severe (174): SIGSEGV, **segmentation fault** occurred (致命的なエラー (174): SIGSEGV、セグメンテーション違反が発生しました。)  
  このメッセージは、**プログラムが不正なメモリー参照を実行しようとしたことを示します**。プログラムにエラーがないか確認してください。  

- severe (174): SIGSEGV, possible program stack overflow occurred (致命的なエラー (174): SIGSEGV、プログラムの**スタック・オーバーフロー**が発生した可能性があります。)  

セグメンテーション違反とは，本来存在しないメモリ番地にプログラムがアクセスを試みた場合に発生するエラーである。配列要素の番号を誤って指定した場合に発生することが多い。

**スタック・オーバーフロー**とは，データの一時記憶用に用意してあるメモリのスタックと呼ばれる領域に，**スタックの容量を上回るデータを記憶させようとした**場合に発生するエラーである。

##### 予備知識：スタックとは

https://uquest.tktk.co.jp/embedded/learning/lecture07-1.html



## デバッグの方法

デバッグは次の手順で行われる

1. エラー箇所の特定

2. エラー原因の特定

3. エラーの修正

4. 修正箇所のテスト

   

### 1. エラー箇所の特定

#### エラーメッセージの把握

エラー発生時に表示されるエラーメッセージは，デバッグをする上でもっとも重要な情報である。まず，エラーメッセージをよく読んで，

- エラーがどこで起こっているか
- どのようなエラーが起こっているか

を把握する。

エラーメッセージは，プログラムが不正終了した直接の原因とその考えられる理由が書いてあるので，よく読むことが必要不可欠である。

記述が簡潔なため，内容が十分に理解できないことも多いが，その場合**エラーメッセージをブラウザで検索**してヒットした記事をいくつか読んでみる。エラーの原因だけでなく，**考えうる解決策**が記載されていることも良くある。



エラーがどこで起こっているかを把握するためには以下を行う

1. デバッグ用のコンパイラオプションの有効化
2.  エラーメッセージの精査

3. PRINT文デバッグ

   

#### デバッグ用のコンパイラオプションの有効化 (FortranやC言語)

実行前にコンパイルが必要な言語 (FortranやC言語)の場合はまず，デバッグ用のコンパイラオプションを有効にする。**コンパイル不要の言語の場合は必要ない** (GrADS, Python, NCLなど)。

##### Intel OneAPI  (FortranやC)の場合

エラー箇所の行番号を表示するオプション (`-traceback`)と配列チェックオプション (`-CB`)を指定する。Intel社製のコンパイラ (ifortやicc)を使用している場合，次の例のようにすればよい。

例：

```
ifort -CB -traceback main.f90 -o main.exe
```

##### gfortran (gcc)の場合

フリーのコンパイラとしてLinuxの標準的なコンパイラとなっているgfortranやgccを使う場合，エラー箇所の行番号を表示するオプション (`-fbacktrace`)と配列チェックオプション (`-fbounds-check`)を用いる



#### エラーメッセージの精査 (すべての言語)

実行時に表示されるエラーメッセージの詳細な内容と解説はWeb上に文書が記載されているので，検索すれば見つけることができる。例えば，

ifort 174で検索すると，以下のような詳細な解説を見つけることができる。まずこのようなWeb上の文書を注意深く読んで，現在発生しているエラーがどのようなエラーか把握すること

https://www.hpc-sol.co.jp/support/tech/ifort_debug/



#### PRINT文デバッグ (すべての言語)

##### バグの箇所の特定

Fortranを例にして説明する。プログラムの半分ぐらいのところに、次の行を加える。

```fortran
print *,'AAA'
```

プログラムを実行した際に、AAAと表示される前にエラーが発生していたら、基本的には加えたPRINT文より前にバグがあるはずである。AAAと表示された後にエラーが発生していたら、PRINT文より後にバグがあるはずである。

前述の作業によって、エラーがある可能性のある範囲がプログラム全体の半分に絞られた。次に絞られた範囲の半分ぐらいのところにPRINT文を加えて同様のことを行う。これを繰り返すと、バグの原因となってる箇所を発見することができる。2のべき乗で範囲が狭まっていくので、繰り返す回数は数回で済む場合が多い。

シェルスクリプト (bashスクリプト)の場合

```bash
echo AAA
```

gradsスクリプトの場合

```bash
say 'AAA'
```

nclスクリプトの場合

```bash
print("AAA")
```

pythonスクリプトの場合

```python
print("AAA")
```



##### 処理過程の確認

計算が合っているかどうか、途中経過を書き出して確認する。

配列を使っていてデータ数が多くなる時は、

- 配列の1要素のみ表示
- 配列のある特定の次元のみ表示
- 配列のある特定の次元のみを間引いて表示

など工夫する。例としてFortranでA (1000, 1000, 1000)という配列を使っている場合

配列の1要素のみ表示

```Fortran
PRINT *,A(1,1,1)
```

配列のある特定の次元のみ表示

```fortran
PRINT *,A(:,1,1)
```

配列のある特定の次元のみを間引いて表示

```fortran
PRINT *,(A(i,1,1),i=1,1000,100)
```



## 大部分のバグの原因はタイプミスである

人間には認知バイアス（思い込み）があるので，**タイプミスは思いのほか見つけずらい**（コピペのミスも含む）。そのため，「あってるはずだよなぁ」と言いながらプログラムを漫然と眺める，という事態に陥りやすい。これは時間の浪費にしかならない。

- **人間はケアレスミスをする**
- ケアレスミスは**プログラムの目視だけでは発見できない**

という前提に立って，**常に動作確認をしながらデバッグを行う**ことが肝要である。



## 上達のためのポイント

**エラーが出た時の対応の仕方でプログラミングの上達の速度が大幅に変わる**。

上記のような検証法を常に試みると上達が早い。ポイントは次の3つである

1. **エラーメッセージをよく読む**
2. **エラーメッセージを検索**し，ヒットした**サイトをよく読む**
3. **変数に関する情報を書き出して確認**する

**エラーメッセージには**，プログラムが不正終了した**直接の原因**とその**考えられる理由**が書いてあるので，よく読むことが必要不可欠である。

記述が簡潔なため，内容が十分に理解できないことも多いが，その場合**エラーメッセージをブラウザで検索**してヒットした記事をいくつか読んでみる。エラーの原因だけでなく，**考えうる解決策**が記載されていることも良くある。

PRINT文デバッグによって, エラーを引き起こしていると思われる箇所の**変数の情報**や**変数の値そのものを書き出して**，**期待した通りにプログラムが動作しているか確認する**ことも重要である。

エラーの場所が特定できれば，エラーの修正の大部分は完了したと考えてもよいほどである。

エラーメッセージや検索してヒットするウェブサイトは英語で記載されていることも多いが，**重要な情報は英語で記載されていることが多い**ので，よく読むようにする。

重要そうに思われるが，一回で理解できないものは，PDFなどに書き出して後で繰り返し読んでみる。どうしても頭に入らないものは印刷してから読む。



## 休憩を入れる

プログラムのバグは，スペルミスなど非常に小さな誤りに起因することが多い。

これを目が疲れた状態で発見するのは容易なことではない。プログラミング作業は目を酷使するので，適度に休憩を入れた方が効率が上がる。モニターを眺める作業を行う場合，1時間に一回は休憩を入れるべきとされている

https://www.fujitsu.com/jp/about/businesspolicy/tech/design/ud/vdt/index-page2.html

**眼精疲労は目の筋肉の疲労**なので，ストレッチも活用するとよい

https://kokoro.mhlw.go.jp/ps/tokyo_stretch_06.html

深呼吸，散歩もよい方法である。体を動かすことで，誤りに気が付くことがよくある。

**休憩時間中はスマホを手から放し**，**休憩に専念する**ことが肝要。

**眼精疲労は目の筋肉の疲労**なので，**スマホ画面を見続けることはモニタを凝視し続けていることと同じ**。



## 質問の仕方

質問にもやり方がある。**上手に質問すれば早く回答が得られる**し、あまり上手でないやり方で質問をすれば時間を要する（もしくは回答が得られない）。

要点は, **回答者が状況を把握できるような情報をできるかぎり与える**ことである。



### 質問に記載する情報

1. 実現したいこと

2. やったこと

3. 結果

   

#### 1. 実現したいこと

- プログラムやコマンドに何をさせたいか

- 入力データから何を計算させたいか

などやりたいことを簡潔に書く



#### 2. やったこと

- 実行したコマンド（コマンドプロンプトに打ち込んだ内容）

- プログラムやスクリプトのリスト（サーバー上のものであればプログラムが存在するディレクトリ名）

  

#### 3. 結果

- エラーメッセージ

  - **画面表示が長すぎる場合、テキストファイルに書き出す**か、一部抜粋する

    ```bash
    プログラム名　&> ERR.TXT　
    ```

    でエラーメッセージがテキストファイルERR.TXTに書き出される。

    

- コマンド, プログラム (スクリプト)の実行結果

  - 画面表示が長すぎる場合、テキストファイルに書き出すか、一部抜粋する
  - 大量の数値データの場合は, **データを図にする** (**大量の数値の羅列からは何の情報も得られない**)




#### 注意

プログラミングに限ったことではないが、回答が得られない問題, 回答するために相応の時間を要する問題があることに注意する。回答者がプログラミング言語や使用しているツールに関するすべてを把握しているわけではなく、さらに回答者が調査・回答に使用できる時間は有限である。

また、人間のやることには必ず誤りがある。特にGrADS, Python, NCLなど多数のライブラリに依存しているツールに関してはライブラリに誤りがある場合もある。また，ライブラリ作成者の意図しない使い方をした場合，予期せぬ結果が得られることもある。このような場合、回答を得るのが困難になる場合がある。

このような場合は**異なる手法で目標に到達できないか, 代替案を考えることも重要**である。例えばプログラミング言語を変更する。実際にあった例としては、GrADS, pythonなどではうまくいかない作業を、Fortranに変更したことが挙げられる。



## 極意

プログラムにわけのわからないバグが発⽣した場合、 私たちが普通取る⾏動は、プログラムを眺めて、上から順に追っていく ことであろう。これは、「⾃分は正しくプログラムを書いている筈」という 先⼊観が邪魔をして、まず成功しない。

だいたいが 最後までプログラムを⾒終わって「うーん、合っているはずだよなぁ」と つぶやくのがせいぜいである。

合っていたらバグなんて発⽣しない。そもそもバグが起きたら 「なんでだよ〜」と思う時点で罠にはまっていると⾔ってよい。 **バグは全て⾃分のせいだ**ということを思い返そう。

プログラムを眺めながら頭の中でプログラムを仮想実⾏する⽅法は あまり良くない。そこで、逆に「**こういうバグが発⽣するとしたら どういう原因が考えられるだろう**」と仮説を立てる。その仮説に従って，起こりうることを次の手順でチェックしていく。

1. バグの原因となりうる具体的な条件をできるだけ多くリストアップする
2. それぞれの条件について、それが原因であることを確かめるための条件を考える
3. 上記の条件を⼀つ⼀つチェックする
4. これで発⾒できなかった場合には、1に戻る

このように、「考えられる原因」と「その対策」を ⼗分練ってからプログラムを⾒る。そのとき 「⾃分はあっているはず」という偏⾒が薄れ、 「バグがあるとしたらこのあたりのはず」という⾒⽅になっているだろう。 これならバグの発⾒率が⾼くなる。

### まとめ

要点は下記の通り。

- エラーに関係する情報を収集する

- エラーの要因は何か仮説を立てる

- 仮説を検証する方法を考える

- 仮説を検証する

  

## 問

[1] コンパイルエラー (compile error), ランタイムエラー (runtime error), ワーニング (warning)の違いを説明せよ。

[2] Syntax errorについて説明せよ。

[3] スタック・オーバーフロー (stack overflow)について説明せよ。

[4] セグメンテーション違反 (segmentation fault)について説明せよ。

[5] IntelOneAPI (ifort)の2つのオプション, -CBと-tracebackについて説明せよ。

## 演習

下記のプログラムのデバッグを行う。

**EX01-01.f90**

```Fortran
program EX01_01
real,dimension(2)::a
a(1)=1.0; a(2)=2.0
call sub(a)
end program

subroutine sub(a,b)
print *,b
end subroutine 
```

上記のプログラムをコンパイルして実行する。

```bash
$ ift
```

もしくは

```bash
$ source /opt/intel/oneapi/setvars.sh
```

```bash
$ ifort EX01-01.f90 -o EX01-01.exe
```

```bash
$ EX01-01.exe 
```

このとき次のエラーが出たとする。

```bash
forrtl: severe (174): SIGSEGV, segmentation fault occurred
Image              PC                Routine            Line        Source             
EX01-01.exe        0000000000404A2A  Unknown               Unknown  Unknown
libpthread-2.17.s  00007FA37C9BA630  Unknown               Unknown  Unknown
EX01-01.exe        0000000000403B34  Unknown               Unknown  Unknown
EX01-01.exe        0000000000403AE2  Unknown               Unknown  Unknown
libc-2.17.so       00007FA37C5FF555  __libc_start_main     Unknown  Unknown
EX01-01.exe        00000000004039E9  Unknown               Unknown  Unknown
```

[1] どのようなエラーが発生しているか述べよ

[2]  -CBと-tracebackオプションをつけて再度コンパイルしたのち、プログラムを実行する。表示されるエラーメッセージについて説明せよ。

[3] program EX01_01で変数bの値に3.0を代入するように変更し, subroutine subで配列aと変数bの値が表示されるようにプログラムを修正せよ。



## 付録：様々なコンパイラオプション

### 注意

- 実行時に速度低下を招くものもあるので，計算時間を要するプログラムの場合, **デバッグが終わったらオプションを外して再コンパイルする**。



### よく使うオプション

- 異常終了時にソースコードの行番号を表示

  -  gfortran: -fbacktrace(ve4.3以上)

  - ifort: -traceback
- 配列の領域外参照を検出

  - gfortran: -fbounds-check

  - ifort: -CB (-check boundsに同じ)
- 浮動小数点例外発生時に異常終了

  - gfortran: "-ffpe-trap=invalid,zero,overflow"
- ifort: -fpe0

- 暗黙の型宣言を警告

  - gfortran:

  - ifort: -warn declarations

- 初期化されていない変数を検出

  - gfortran: -O -Wuninitialized

  - ifort: -check uninit


- デバッグデータの生成

  - gfortran: -g(or -ggdb)

  - ifort: -g

- 全ての実行時診断機能を有効

  - gfortran: なし

  - ifort: -check all

- 全てのコンパイル時警告メッセージを有効

  - gfortran: -Wall

  - ifort: -warn all

- 標準外機能の利用を警告

  - gfortran: -pedantic -std=f95

  - ifort: -std

  

### オプション指定例

以下の例では、a.f90というソースファイルをオプションを指定してコンパイルしている。

#### gfortran

```bash
gfortran -Wall -pedantic -std=f95 -fbounds-check -O -Wuninitialized -ffpe-trap=invalid,zero,overflow a.f90
```

- '-fbacktrace'が使えない場合はデバッガを使う(下記参照)

#### ifort

```bash
ifort -check all -warn all -std -gen_interfaces -fpe0 -ftrapuv -traceback a.f90
```

- -gen_interfaces：subroutineやfunctionのINTERFACEブロックを作ってくれる 

  →　引数の不整合などのチェックが行われる

- -ftrapuv：動的に割り当てる変数を0xccccccccで初期化するので，初期化漏れによるバグを洗い出すのに役立つ



## 付録：デバッガ (debugger)

デバッグを行うための専用のソフトウェア (アプリ)のことをデバッガという。

たとえば，Linux標準のデバッガであるgdbは以下の手順で使用することができる。

- `-g`オプションをつけてコンパイルする

- 実行ファイルを実行すると，異常終了時にcoreという名称のファイルができる。このファイルに異常終了時のコンピューターの状況が記録されている。

  ```
  gdb 実行ファイル名 core
  ```

で異常終了した場所などがわかる

- gdbは`quit`で終了できる。

もしくは次のような方法がある

- デバッガを起動して, デバッガ上で実行ファイルを実行してみる（起動時に実行ファイル名を指定すればファイルを読み込むのは省略できる）

### 使用例

#### gfortran

```bash
$ gdb
(gdb) exec-file a.out
(gdb) run a.out
(gdb) quit
```

#### ifort

```bash
$ idb
(idb) file a.out
(idb) run a.out
(gdb) quit
```

